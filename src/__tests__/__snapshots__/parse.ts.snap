// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`parse_type should return correctly 1`] = `
Object {
  "generics": Array [
    Object {
      "defalut": undefined,
      "extends": undefined,
      "kind": 13,
      "name": "T",
    },
    Object {
      "defalut": undefined,
      "extends": undefined,
      "kind": 13,
      "name": "U",
    },
  ],
  "kind": 11,
  "parameters": Array [
    Object {
      "kind": 32,
      "name": "x",
      "optional": undefined,
      "rest": undefined,
      "type": Object {
        "generics": undefined,
        "kind": 12,
        "name": "T",
        "parents": undefined,
      },
    },
    Object {
      "kind": 32,
      "name": "y",
      "optional": undefined,
      "rest": undefined,
      "type": Object {
        "generics": undefined,
        "kind": 12,
        "name": "U",
        "parents": undefined,
      },
    },
  ],
  "return": Object {
    "kind": 41,
    "types": Array [
      Object {
        "generics": undefined,
        "kind": 12,
        "name": "T",
        "parents": undefined,
      },
      Object {
        "generics": undefined,
        "kind": 12,
        "name": "U",
        "parents": undefined,
      },
      Object {
        "kind": 29,
        "type": TokenObject {
          "end": -1,
          "flags": 8,
          "kind": 105,
          "parent": undefined,
          "pos": -1,
        },
      },
    ],
  },
}
`;

exports[`should return correctly 1`] = `
"/// <reference path=\\"some-path\\" />
/// <reference types=\\"some-types\\" />
declare var v_var: any;
declare let v_let: any;
declare const v_const: any;
declare const v_any: any;
declare const v_boolean: boolean;
declare const v_never: never;
declare const v_null: null;
declare const v_number: number;
declare const v_object: object;
declare const v_string: string;
declare const v_symbol: symbol;
declare const v_this: this;
declare const v_undefined: undefined;
declare const v_void: void;
declare const v_array: any[];
declare const v_constructor: new <T>(v: T) => any;
declare const v_function: <T>(v: T) => any;
declare const v_function_predicate_1: () => this is string;
declare const v_function_predicate_2: (v: any) => v is string;
declare const v_general: X.Y.Z<string>;
declare const v_intersection: string & number;
declare const v_keyof: keyof X;
declare const v_literal_true: true;
declare const v_literal_false: false;
declare const v_literal_number: 123;
declare const v_literal_string: \\"str\\";
declare const v_mapped: {
    [T in keyof X]: any;
};
declare const v_mapped_readonly: {
    readonly [T in keyof X]: any;
};
declare const v_mapped_optional: {
    [T in keyof X]?: any;
};
declare const v_object: {
    readonly a?: any;
    b?<T>(v: T): any;
    o(v?: string): void;
    r(...v: string[]): string;
    r2(...v: any[]): any;
    r3(...v: string[][]): any;
    new (): any;
    (): any;
    <T>(v: T): T;
    new <T>(v: T): any;
    readonly [index: number]: any;
};
declare const v_sub_1: X[any][\\"abc\\"][123];
declare const v_sub_2: A.B.C[X[any]][any];
declare const v_tuple: [string, number];
declare const v_typeof_1: typeof X;
declare const v_typeof_2: typeof X.Y.Z;
declare const v_union: string | number;
import \\"path/to/somewhere\\";
import import_default from \\"path/to/somewhere\\";
import import_default1, * as import_namespace1 from \\"path/to/somewhere\\";
import * as import_namespace2 from \\"path/to/somewhere\\";
import import_default2, { im_0 as im_1, im_2 } from \\"path/to/somewhere\\";
import { im_3 as im_4, im_5 } from \\"path/to/somewhere\\";
export default X;
export default X.Y.Z;
export = A;
export = A.B.C;
export { ex_0 as ex_1, ex_2 };
export as namespace NS;
export * from \\"path/to/somewhere\\";
export { ex_3 as ex_4, ex_5 } from \\"path/to/somewhere\\";
export declare class ZXC extends X.Y.Z {
}
export declare abstract class ABC<T, U> extends XYZ<S, V> {
    constructor();
    method?(): void;
    public method1<T>(v: T): T;
    protected method2(): void;
    private method3(): void;
    public abstract method4(): void;
    property?: string;
    public property1: string;
    protected property2: string;
    private property3: string;
    public abstract property4: string;
    \\"\\": string;
    \\"\\"(): void;
}
declare enum Kind {
    A = 0,
    B = 123,
    C = 124
}
export interface X<T> extends C, D {
    a: T;
    \\"\\": T;
    \\"\\"(): void;
}
export declare namespace NS {
    const ns: any;
}
declare global {
    interface String {
        toXYZ(): any;
    }
}
declare module \\"xyz\\" {
    const aa: string;
}
type TP<T> = T | string;
type adjust = <T, U>(fn: (v: T) => U, index: number, array: T[]) => (T | U)[];
declare function x<T>(v: T): T;
import xyz = require(\\"xyz\\");
type X = A[B[C]];
"
`;
